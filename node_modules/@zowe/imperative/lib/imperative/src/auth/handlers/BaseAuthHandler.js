"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAuthHandler = void 0;
const constants_1 = require("../../../../constants");
const rest_1 = require("../../../../rest");
const Imperative_1 = require("../../Imperative");
const expect_1 = require("../../../../expect");
const error_1 = require("../../../../error");
const utilities_1 = require("../../../../utilities");
/**
 * This class is used by the auth command handlers as the base class for their implementation.
 */
class BaseAuthHandler {
    /**
     * This handler is used for both "auth login" and "auth logout" commands.
     * It determines the correct action to take and calls either `processLogin`
     * or `processLogout` accordingly.
     *
     * @param {IHandlerParameters} commandParameters Command parameters sent by imperative.
     *
     * @returns {Promise<void>}
     */
    process(commandParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (commandParameters.positionals[1]) {
                case constants_1.Constants.LOGIN_ACTION:
                    yield this.processLogin(commandParameters);
                    break;
                case constants_1.Constants.LOGOUT_ACTION:
                    yield this.processLogout(commandParameters);
                    break;
                default:
                    throw new error_1.ImperativeError({
                        msg: `The group name "${commandParameters.positionals[1]}" was passed to the BaseAuthHandler, but it is not valid.`
                    });
                    break;
            }
        });
    }
    /**
     * Performs the login operation. Builds a session to connect to the auth
     * service, sends a login request to it to obtain a token, and stores the
     * resulting token in the profile of type `mProfileType`.
     * @param {IHandlerParameters} params Command parameters sent by imperative.
     */
    processLogin(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const loadedProfile = params.profiles.getMeta(this.mProfileType, false);
            const sessCfg = this.createSessCfgFromArgs(params.arguments);
            const sessCfgWithCreds = yield rest_1.ConnectionPropsForSessCfg.addPropsOrPrompt(sessCfg, params.arguments, { requestToken: true, defaultTokenType: this.mDefaultTokenType });
            this.mSession = new rest_1.Session(sessCfgWithCreds);
            // login to obtain a token.
            const tokenValue = yield this.doLogin(this.mSession);
            // validate a token was returned
            if (tokenValue == null) {
                throw new error_1.ImperativeError({ msg: "A token value was not returned from the login handler." });
            }
            // update the profile given
            if (!params.arguments.showToken) {
                let profileWithToken = null;
                if (loadedProfile != null && loadedProfile.name != null) {
                    yield Imperative_1.Imperative.api.profileManager(this.mProfileType).update({
                        name: loadedProfile.name,
                        args: {
                            "token-type": this.mSession.ISession.tokenType,
                            "token-value": tokenValue
                        },
                        merge: true
                    });
                    profileWithToken = loadedProfile.name;
                }
                else {
                    // Do not store non-profile arguments, user, or password. Set param arguments for prompted values from session.
                    const copyArgs = Object.assign({}, params.arguments);
                    copyArgs.createProfile = undefined;
                    copyArgs.showToken = undefined;
                    copyArgs.user = undefined;
                    copyArgs.password = undefined;
                    copyArgs.host = this.mSession.ISession.hostname;
                    copyArgs.port = this.mSession.ISession.port;
                    copyArgs.tokenType = this.mSession.ISession.tokenType;
                    copyArgs["token-type"] = this.mSession.ISession.tokenType;
                    copyArgs.tokenValue = tokenValue;
                    copyArgs["token-value"] = tokenValue;
                    const createParms = {
                        name: "default",
                        type: this.mProfileType,
                        args: copyArgs,
                        overwrite: false,
                        profile: {}
                    };
                    const answer = yield utilities_1.CliUtils.promptWithTimeout(`Do you want to store the host, port, and token on disk for use with future commands? If you answer Yes, the credentials will ` +
                        `be saved to a ${this.mProfileType} profile named '${createParms.name}'. If you answer No, the token will be printed to the ` +
                        `terminal and will not be stored on disk. [y/N]: `);
                    if (answer != null && (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes")) {
                        yield Imperative_1.Imperative.api.profileManager(this.mProfileType).save(createParms);
                        profileWithToken = createParms.name;
                    }
                    else {
                        params.arguments.showToken = true;
                    }
                }
                if (profileWithToken != null) {
                    params.response.console.log(`\n` +
                        `Login successful. The authentication token is stored in the '${profileWithToken}' ` +
                        `${this.mProfileType} profile for future use. To revoke this token and remove it from your profile, review the ` +
                        `'zowe auth logout' command.`);
                }
            }
            // show token instead of updating profile
            if (params.arguments.showToken) {
                params.response.console.log(`\n` +
                    `Received a token of type = ${this.mSession.ISession.tokenType}.\n` +
                    `The following token was retrieved and will not be stored in your profile:\n` +
                    `${tokenValue}\n\n` +
                    `Login successful. To revoke this token, review the 'zowe auth logout' command.`);
                params.response.data.setObj({ tokenType: this.mSession.ISession.tokenType, tokenValue });
            }
        });
    }
    /**
     * Performs the logout operation. Deletes the token and token type from the profile,
     * and rebuilds the session.
     * @param {IHandlerParameters} params Command parameters sent by imperative.
     */
    processLogout(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const loadedProfile = params.profiles.getMeta(this.mProfileType, false);
            expect_1.ImperativeExpect.toNotBeNullOrUndefined(params.arguments.tokenValue, "Token value not supplied, but is required for logout.");
            // Force to use of token value, in case user and/or password also on base profile, make user undefined.
            if (params.arguments.user != null) {
                params.arguments.user = undefined;
            }
            params.arguments.tokenType = this.mDefaultTokenType;
            const sessCfg = this.createSessCfgFromArgs(params.arguments);
            const sessCfgWithCreds = yield rest_1.ConnectionPropsForSessCfg.addPropsOrPrompt(sessCfg, params.arguments, { requestToken: false });
            this.mSession = new rest_1.Session(sessCfgWithCreds);
            yield this.doLogout(this.mSession);
            // If you specified a token on the command line, then don't delete the one in the profile if it doesn't match
            let profileWithToken = null;
            if (loadedProfile != null &&
                loadedProfile.name != null &&
                loadedProfile.profile != null &&
                loadedProfile.profile.tokenValue != null &&
                params.arguments.tokenValue === loadedProfile.profile.tokenValue) {
                yield Imperative_1.Imperative.api.profileManager(this.mProfileType).save({
                    name: loadedProfile.name,
                    type: loadedProfile.type,
                    overwrite: true,
                    profile: Object.assign(Object.assign({}, loadedProfile.profile), { tokenType: undefined, tokenValue: undefined })
                });
                profileWithToken = loadedProfile.name;
            }
            this.mSession.ISession.type = rest_1.SessConstants.AUTH_TYPE_BASIC;
            this.mSession.ISession.tokenType = undefined;
            this.mSession.ISession.tokenValue = undefined;
            params.response.console.log("Logout successful. The authentication token has been revoked" +
                (profileWithToken != null ? ` and removed from your '${profileWithToken}' ${this.mProfileType} profile` : "") +
                ".");
        });
    }
}
exports.BaseAuthHandler = BaseAuthHandler;
//# sourceMappingURL=BaseAuthHandler.js.map