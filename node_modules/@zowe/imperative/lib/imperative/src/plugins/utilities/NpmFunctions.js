"use strict";
/*
* This program and the accompanying materials are made available under the terms of the
* Eclipse Public License v2.0 which accompanies this distribution, and is available at
* https://www.eclipse.org/legal/epl-v20.html
*
* SPDX-License-Identifier: EPL-2.0
*
* Copyright Contributors to the Zowe Project.
*
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageInfo = exports.npmLogin = exports.getRegistry = exports.installPackages = exports.cmdToRun = void 0;
const PMFConstants_1 = require("./PMFConstants");
const path = require("path");
const child_process_1 = require("child_process");
const jsonfile_1 = require("jsonfile");
const npmPackageArg = require("npm-package-arg");
const pacote = require("pacote");
const npmCmd = cmdToRun();
/**
 * Common function that requires npm and node.exe if not found just returns npm command as a string.
 *
 * @return {string} command with node.exe and npm paths or 'npm'
 *
 */
function cmdToRun() {
    let command;
    try {
        const npmExecPath = path.join(require.resolve("npm"), "../..");
        const nodeExecPath = process.execPath;
        command = `"${nodeExecPath}" "${npmExecPath}"`;
    }
    catch (err) {
        command = "npm";
    }
    return command;
}
exports.cmdToRun = cmdToRun;
/**
 * Common function that installs a npm package using the local npm cli.
 * @param {string} prefix Path where to install npm the npm package.
 *
 * @param {string} registry The npm registry to install from.
 *
 * @param {string} npmPackage The name of package to install.
 *
 * @return {string} command response
 *
 */
function installPackages(prefix, registry, npmPackage) {
    const pipe = ["pipe", "pipe", process.stderr];
    try {
        const execOutput = child_process_1.execSync(`${npmCmd} install "${npmPackage}" --prefix "${prefix}" ` +
            `-g --registry "${registry}" --legacy-peer-deps`, {
            cwd: PMFConstants_1.PMFConstants.instance.PMF_ROOT,
            stdio: pipe
        });
        return execOutput.toString();
    }
    catch (err) {
        throw (err.message);
    }
}
exports.installPackages = installPackages;
/**
 * Get the registry to install to.
 *
 * @return {string}
 */
function getRegistry() {
    try {
        const execOutput = child_process_1.execSync(`${npmCmd} config get registry`);
        return execOutput.toString();
    }
    catch (err) {
        throw (err.message);
    }
}
exports.getRegistry = getRegistry;
/**
 * NPM login to be able to install from secure registry
 * @param {string} registry The npm registry to install from.
 */
function npmLogin(registry) {
    try {
        child_process_1.execSync(`${npmCmd} adduser --registry ${registry} ` +
            `--always-auth --auth-type=legacy`, { stdio: [0, 1, 2] });
    }
    catch (err) {
        throw (err.message);
    }
}
exports.npmLogin = npmLogin;
/**
 * Fetch name and version of NPM package that was installed
 * @param pkgSpec The package name as specified on NPM install
 */
function getPackageInfo(pkgSpec) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgInfo = npmPackageArg(pkgSpec);
        if (pkgInfo.registry) {
            // We already know package name, so read name and version from package.json
            return jsonfile_1.readFileSync(path.join(PMFConstants_1.PMFConstants.instance.PLUGIN_NODE_MODULE_LOCATION, pkgInfo.name, "package.json"));
        }
        else {
            // Package name is unknown, so fetch name and version with pacote (npm SDK)
            return pacote.manifest(pkgSpec);
        }
    });
}
exports.getPackageInfo = getPackageInfo;
//# sourceMappingURL=NpmFunctions.js.map